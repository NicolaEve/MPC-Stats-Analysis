---
title: "MPC"
author: "NCompton"
date: "28/06/2021"
output: html_document
---

knit at end

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

install packages and set libraries
```{r, echo = FALSE}
#install.packages("odbc")
#install.packages("DBI")
#install.packages("dplyr")
#install.packages("fitdistrplus")
#install.packages("ggplot2")
#install.packages("qicharts2")
#install.packages("psych")
#install.packages("distributions3")
library(psych)
library(qicharts2)
library(ggplot2)
library(fitdistrplus)
library(dplyr)
library(odbc)
library(distributions3)
```

Define functions
is the z test paired? 
```{r}
# function to check the distribution of the data input
check_distribution <- function(data){
  descdist(data, discrete = FALSE)
  normal_dist <- fitdist(data, "norm")
  plot(normal_dist)
}

check_all_distr <- function(df){
check_distribution(df$SymmInAT)
check_distribution(df$SymmInBT)
check_distribution(df$SymmCrossAT)
check_distribution(df$SymmCrossBT)

check_distribution(df$FlatInAT)
check_distribution(df$FlatInBT)
check_distribution(df$FlatCrossAT)
check_distribution(df$FlatCrossBT)

check_distribution(df$MPC_Distance)
check_distribution(df$Calibrated_Distance)

check_distribution(df$Output_Change)

check_distribution(df$Uniformity)
}


wilcox_all <- function(df){
print(wilcox.test(df$SymmInAT, df$SymmInBT, paired = TRUE))
print(wilcox.test(df$SymmCrossBT, df$SymmCrossAT, paired = TRUE))

print(wilcox.test(df$SymmInAT, df$SymmCrossAT, paired = TRUE))
print(wilcox.test(df$SymmInBT, df$SymmCrossBT, paired = TRUE))

print(wilcox.test(df$FlatCrossAT, df$FlatCrossBT, paired = TRUE))
print(wilcox.test(df$FlatInAT, df$FlatInBT, paired = TRUE))

print(wilcox.test(df$FlatInAT, df$FlatCrossAT, paired = TRUE))
print(wilcox.test(df$FlatInBT, df$FlatCrossBT, paired = TRUE))
}

# function to return 2-sample z statistic and p value
z.test <- function(x, y){
  # get the sample mean, sd and n
  mu_1 = mean(x)
  mu_2 = mean(y)
  sigma_1 = sd(x)^2
  sigma_2 = sd(y)^2
  n_1 = length(x)
  n_2 = length(y)
  
  # calculate 2 tailed z stat
  z_stat = (mu_1 - mu_2) / (sqrt ((sigma_1/n_1) + (sigma_2/n_2)))
  
  # calculate p value
  Z <- Normal(0,1) # make a standard normal r.v
  p = 2 * cdf(Z, abs(z_stat))
  return(c(z_stat, p))
}
```


Set up the database connection
```{r}
#sort(unique(odbcListDrivers()[[1]]))
con <- DBI::dbConnect(odbc::odbc(), 
                      Driver = "SQL Server", 
                      Server = "IT049561\\SQLEXPRESS", 
                      Database = "MPC", 
                      Trusted_Connection = "True")
```


Get a dataframe for each beam energy
```{sql connection=con, output.var = "df6x"}
SELECT *
FROM "6x"
```
```{sql connection=con, output.var = "df10x"}
SELECT *
FROM "10x"

```
```{sql connection=con, output.var = "df10fff"}
SELECT *
FROM "10fff"

```


Descriptive statistics with psych
```{r, echo = FALSE}
centre_shift_mpc <- describeBy(mpc_view$MPC_Distance, mpc_view$Beam_Energy)
centre_shift_mpc

centre_shift_calibrated <- describeBy(mpc_view$Calibrated_Distance, mpc_view$Beam_Energy)
centre_shift_calibrated

uniformity_mpc <- describeBy(mpc_view$Uniformity, mpc_view$Beam_Energy)
uniformity_mpc

output_change_mpc <- describeBy(mpc_view$OutputChange, mpc_view$Beam_Energy)
output_change_mpc
```

check distributions are normal

```{r}
check_all_distr(df6x)
#check_all_distr(df10x)
#check_all_distr(df10fff)
```


get a dataframe for the values since the water phantom was imaged

```{sql connection=con, output.var=recent6x}
SELECt *
FROM "6x"
WHERE QA_Date >= '2021-04-01'

```

```{sql connection=con, output.var=recent10x}
SELECt *
FROM "10x"
WHERE QA_Date >= '2021-04-01'

```

```{sql connection=con, output.var=recent10fff}
SELECt *
FROM "10fff"
WHERE QA_Date >= '2021-04-01'

```

check distriubtions of the recent ones
```{r}
check_all_distr(recent6x)
check_all_distr(recent10x)
check_all_distr(recent10fff)
```


Shapiro -wilk test for normality
None of the variables are normally distibuted

```{r}
# check if the distribution is normal using a sharpio-wilk test
# p<0.5 means the distribution is not normal
shapiro.test(df10x$SymmCrossAT)
shapiro.test(df10x$SymmCrossBT)
shapiro.test(df10x$SymmInAT)
shapiro.test(df10x$SymmInBT)

shapiro.test(df10x$FlatCrossAT)
shapiro.test(df10x$FlatCrossBT)
shapiro.test(df10x$FlatInAT)
shapiro.test(df10x$FlatInBT)

shapiro.test(df10x$MPC_Distance)
shapiro.test(df10x$Calibrated_Distance)
shapiro.test(df10x$Output_Change)
shapiro.test(df10x$Uniformity)


shapiro.test(df10fff$SymmCrossAT)
shapiro.test(df10fff$SymmCrossBT)
shapiro.test(df10fff$SymmInAT)
shapiro.test(df10fff$SymmInBT)

shapiro.test(df10fff$FlatCrossAT)
shapiro.test(df10fff$FlatCrossBT)
shapiro.test(df10fff$FlatInAT)
shapiro.test(df10fff$FlatInBT)

shapiro.test(df10fff$MPC_Distance)
shapiro.test(df10fff$Calibrated_Distance)
shapiro.test(df10fff$Output_Change)
shapiro.test(df10fff$Uniformity)


shapiro.test(df6x$SymmCrossAT)
shapiro.test(df6x$SymmCrossBT)
shapiro.test(df6x$SymmInAT)
shapiro.test(df6x$SymmInBT)

shapiro.test(df6x$FlatCrossAT)
shapiro.test(df6x$FlatCrossBT)
shapiro.test(df6x$FlatInAT)
shapiro.test(df6x$FlatInBT)

shapiro.test(df6x$MPC_Distance)
shapiro.test(df6x$Calibrated_Distance)
shapiro.test(df6x$Output_Change)
shapiro.test(df6x$Uniformity)


```

Comparing the symmetry and flatness before and after the calibration applied; and in inline and crossline directions
p<0.05 so we say the distributions are significantly different
So applying the calibration significantyl changes the distribtion
before calibration, inline and crossline are significantly different but after they're not for symmetry; and both sig diff for flat.
```{r}
wilcox_all(df6x)
wilcox_all(recent6x)
wilcox_all(df10x)
wilcox_all(recent10x)
wilcox_all(df10fff)
wilcox_all(recent10fff)
```
beam centre shift
```{r}
wilcox.test(df6x$MPC_Distance, df6x$Calibrated_Distance)
wilcox.test(df10x$MPC_Distance, df10x$Calibrated_Distance)
wilcox.test(df10fff$MPC_Distance, df10fff$Calibrated_Distance)

wilcox.test(recent6x$MPC_Distance, recent6x$Calibrated_Distance)
wilcox.test(recent10x$MPC_Distance, recent10x$Calibrated_Distance)
wilcox.test(recent10fff$MPC_Distance, recent10fff$Calibrated_Distance)
```

Thresholds for passing the MPC tests are
centre shift = 0.5
OutputChange = 2
Uniformity = 2
Create a conditional column for if it passed/failed on my algorithm and on mpc
will this give sensitivity and specificity ?
or it will give another metric for comparitive stats
there's no mpc that fail and loads of calibrated that do
should there be a cut off?
```{r}
mpc_6x$mpc_distance_pass <- "fail"
mpc_6x$mpc_distance_pass[mpc_6x$MPC_Distance<0.5 & mpc_6x$MPC_Distance> -0.5] <- "pass"
```

Add column which will be a pass/fail for the mpc uniformity and one for if any of the 4 symm/flat fails
or for how sensitive the symm is to uniformity and then how sensitive flatness is to uniformity
Then we can do sensitivty and specifity
```{r}
df6x$uniformity_test <- "fail"
df6x$uniformity_test[df6x$Uniformity<2 & df6x$Uniformity>-2] <- "pass"

df6x$symm_test <- "fail"
df6x$symm_test[df6x$SymmInAT<2 & df6x$SymmInAT>-2 & df6x$SymmCrossAT<2 & df6x$SymmCrossAT>-2] <- "pass"


recent6x$uniformity_test <- "fail"
recent6x$uniformity_test[recent6x$Uniformity<2 & recent6x$Uniformity>-2] <- "pass"

recent6x$symm_test <- "fail"
recent6x$symm_test[recent6x$SymmInAT<2 & recent6x$SymmInAT>-2 & recent6x$SymmCrossAT<2 & recent6x$SymmCrossAT>-2] <- "pass"

false_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$symm_test == "fail")
true_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$symm_test == "pass")
false_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$symm_test == "pass")
true_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$symm_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$uniformity_test == "pass" & df6x$symm_test == "fail")
true_pos <- sum(df6x$uniformity_test == "pass" & df6x$symm_test == "pass")
false_neg <- sum(df6x$uniformity_test == "fail" & df6x$symm_test == "pass")
true_neg <- sum(df6x$uniformity_test == "fail" & df6x$symm_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```
```{r}
df6x$flat_test <- "fail"
df6x$flat_test[df6x$FlatInAT<104 & df6x$FlatCrossAT<104] <- "pass"

recent6x$flat_test <- "fail"
recent6x$flat_test[recent6x$FlatInAT<104 & recent6x$FlatCrossAT<104] <- "pass"

false_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$flat_test == "fail")
true_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$flat_test == "pass")
false_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$flat_test == "pass")
true_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$flat_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$uniformity_test == "pass" & df6x$flat_test == "fail")
true_pos <- sum(df6x$uniformity_test == "pass" & df6x$flat_test == "pass")
false_neg <- sum(df6x$uniformity_test == "fail" & df6x$flat_test == "pass")
true_neg <- sum(df6x$uniformity_test == "fail" & df6x$flat_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```
sens/spec of beam centre shift
the MPC distance is always within 0.5mm threshold
```{r}
df6x$centre_mpc_test <- "fail"
df6x$centre_mpc_test[df6x$MPC_Distance<0.5 & df6x$MPC_Distance>-0.5] <- "pass"

df6x$centre_cal_test <- "fail"
df6x$centre_cal_test[df6x$Calibrated_Distance<0.5 & df6x$Calibrated_Distance>-0.5] <- "pass"

recent6x$centre_mpc_test <- "fail"
recent6x$centre_mpc_test[recent6x$MPC_Distance<0.5 & recent6x$MPC_Distance>-0.5] <- "pass"

recent6x$centre_cal_test <- "fail"
recent6x$centre_cal_test[recent6x$Calibrated_Distance<0.5 & recent6x$Calibrated_Distance>-0.5] <- "pass"

false_pos <- sum(recent6x$centre_mpc_test == "pass" & recent6x$centre_cal_test == "fail")
true_pos <- sum(recent6x$centre_mpc_test == "pass" & recent6x$centre_cal_test == "pass")
false_neg <- sum(recent6x$centre_mpc_test == "fail" & recent6x$centre_cal_test == "pass")
true_neg <- sum(recent6x$centre_mpc_test == "fail" & recent6x$centre_cal_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$centre_mpc_test == "pass" & df6x$centre_cal_test == "fail")
true_pos <- sum(df6x$centre_mpc_test == "pass" & df6x$centre_cal_test == "pass")
false_neg <- sum(df6x$centre_mpc_test == "fail" & df6x$centre_cal_test == "pass")
true_neg <- sum(df6x$centre_mpc_test == "fail" & df6x$centre_cal_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```


Regression on the beam output change against time
should it be linear?

```{r}
lm <- lm(OutputChange ~ QA_Date, data = mpc_6x)
summary(lm)
```

plot the beam output change over time
```{r}
ggplot(df6x, aes(QA_Date, Output_Change)) +
  geom_point() +
  xlab("QA Date") +
  ylab("Output Change") +
  ggtitle("Output Changes against Time")

```


SPC charts for the beam centre shift over time;
the flatness and symmetry over time
```{r}

qic(df10x$MPC_Distance, chart = 'i')
qic(df10x$Calibrated_Distance, chart = 'i')
qic(df10x$MPC_Distance, chart = 'mr')
qic(df10x$Calibrated_Distance, chart = 'mr')

qic(df6x$Output_Change, x = df6x$QA_Date, chart = 'xbar')

qic(df6x$SymmInAT, chart = 'mr')

```


```{r}
qic(recent6x$SymmInAT, x = recent6x$QA_Date, chart = 'mr')
```
box cox transformation to normal distribution
```{r}
library(MASS)
help(boxcox)

boxcox(recent6x$SymmInAT~1)

```

