---
title: "MPC"
author: "NCompton"
date: "28/06/2021"
output: html_document
---

knit at end

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

install packages and set libraries
```{r, echo = FALSE}
#install.packages("odbc")
#install.packages("DBI")
#install.packages("dplyr")
#install.packages("fitdistrplus")
#install.packages("ggplot2")
#install.packages("qicharts2")
#install.packages("psych")
#install.packages("distributions3")
#install.packages("ggstatsplot")
#install.packages("forecast")
library(psych)
library(qicharts2)
library(ggplot2)
library(fitdistrplus)
library(dplyr)
library(odbc)
library(distributions3)
library(ggstatsplot)
library(forecast)
```

Define functions

```{r}
# function to return 2-sample z statistic and p value
z.test <- function(x, y){
  # get the sample mean, sd and n
  mu_1 = mean(x)
  mu_2 = mean(y)
  sigma_1 = sd(x)^2
  sigma_2 = sd(y)^2
  n_1 = length(x)
  n_2 = length(y)
  
  # calculate 2 tailed z stat
  z_stat = (mu_1 - mu_2) / (sqrt ((sigma_1/n_1) + (sigma_2/n_2)))
  
  # calculate p value
  Z <- Normal(0,1) # make a standard normal r.v
  p = 2 * cdf(Z, abs(z_stat))
  return(c(z_stat, p))
}
```

```{r}
z.paired <- function(x, y, d0, alpha){
  if(missing(d0)){d0 <- 0}
  if(missing(alpha)){alpha <- 0.05}
  mean_diff <- mean(x-y)
  sigma_diff <- sqrt(var(x)+var(y)-2*cov(x,y))
  n <- length(x)
  z<-sqrt(n)*((mean_diff-d0)/sigma_diff)
  p_value=2*pnorm(-abs(z))
  
    # qnorm gives the alpha quantile of the standard normal  distribution
  # reject H0 that difference of means = d0 if z < z(alpha/2) or
  # z > z(1-alpha/2)
  
  
  if(z < qnorm(alpha/2)) {cat("Null hypothesis can be rejected. Evidence the difference in means is not equal to", d0)}
  if (z > qnorm(1 - (alpha/2))) {
  cat("Null hypothesis can be rejected. Evidence the difference in means is not equal to", d0)}
  if ( qnorm(alpha/2)< z & z < qnorm(1- (alpha/2))) {  cat("Null hypothesis can not be rejected, evidence the difference in means is equal to", d0)}
  
  return(c(z, p_value))
}
```

```{r}
Symm_Flat_Rel <- function(df){
  print("Symmetry Crossline and Inline")
print(cor.test(df$SymmCrossAT, df$SymmInAT))

print("Uniformity and Inline Symmetry")
print(cor.test(df$Uniformity, df$SymmInAT))

print("Uniformity and Crossline Symmetry")
print(cor.test(df$Uniformity, df$SymmCrossAT))

print("Flatness Crossline and Inline")
print(cor.test(df$FlatInAT, df$FlatCrossAT))

print("Uniformity and Inline Flatness")
print(cor.test(df$Uniformity, df$FlatInAT))

print("Uniformity and Crossline Flatness")
print(cor.test(df$Uniformity, df$FlatCrossAT))

print("Output change and symmetry inline")
print(cor.test(df$Output_Change, df$SymmInAT))

print("Output change and symmetry crossline")
print(cor.test(df$Output_Change, df$SymmCrossAT))

print("Output change and flatness inline")
print(cor.test(df$Output_Change, df$FlatInAT))

print("Output change and flatness crossline")
print(cor.test(df$Output_Change, df$FlatCrossAT))
}
```

```{r}
plot_cor <- function(df, energy){
print(ggplot(df, aes(x = SymmInAT, y = SymmCrossAT)) +
  geom_point(color = "red") +
    geom_smooth(method='loess') +
    xlab("Symmetry Inline") + 
    ylab("Symmetry Crossline") + 
    labs(title = energy))

print(ggplot(df, aes(x = Uniformity)) +
  geom_point(aes(y = SymmInAT), color = "blue") +
  geom_point(aes(y = SymmCrossAT), color = "yellow") +
  geom_smooth(aes(x = Uniformity, y = SymmInAT), method = 'loess', color = "blue") +
  geom_smooth(aes(x = Uniformity, y = SymmCrossAT), method = 'loess', color = "yellow") +
  xlab("Uniformity") +
  ylab("Symmetry") +
    labs(title = energy))

print(ggplot(df, aes(Output_Change)) +
  geom_point(aes(y = SymmInAT), color = "blue") +
  geom_point(aes(y = SymmCrossAT), color = "yellow") +
     geom_smooth(aes(x = Output_Change, y = SymmInAT), method = 'loess', color = "blue") +
  geom_smooth(aes(x = Output_Change, y = SymmCrossAT), method = 'loess', color = "yellow") +
  xlab("Output Change") + 
  ylab("Symmetry") +
    labs(title = energy))

print(ggplot(df, aes(x = FlatInAT, y = FlatCrossAT)) +
  geom_point(color = "red") +
    geom_smooth(method='loess') +
   xlab("Flatness Inline") + 
  ylab("Flatness Crossline") +
    labs(title = energy))

print(ggplot(df, aes(Uniformity)) +
  geom_point(aes(y = FlatInAT), color = "blue") +
  geom_point(aes(y = FlatCrossAT), color = "yellow") +
     geom_smooth(aes(x = Uniformity, y = FlatInAT), method = 'loess', color = "blue") +
  geom_smooth(aes(x = Uniformity, y = FlatCrossAT), method = 'loess', color = "yellow") +
  xlab("Uniformity") + 
  ylab("Flatness") +
    labs(title = energy))

print(ggplot(df, aes(Output_Change)) +
  geom_point(aes(y = FlatInAT), color = "blue") +
  geom_point(aes(y = FlatCrossAT), color = "yellow") + 
  geom_smooth(aes(x = Output_Change, y = FlatInAT), method = 'loess', color = "blue") +
  geom_smooth(aes(x = Output_Change, y = FlatCrossAT), method = 'loess', color = "yellow") +
  xlab("Output Change") +
  ylab("Flatness") +
    labs(title = energy))

print(ggplot(df, aes(x = MPC_Distance, y = Calibrated_Distance)) +
        geom_point(color = "red") +
        xlab("MPC Centre Shift") +
        ylab("Calibrated Centre Shift") +
        labs(title = energy))

}
```

```{r}
sens_spec <- function(var1, var2){

false_pos <- sum(var1 == "pass" & var2 == "fail")
true_pos <- sum(var1 == "pass" & var2 == "pass")
false_neg <- sum(var1 == "fail" & var2 == "pass")
true_neg <- sum(var1 == "fail" & var2 == "fail")

sens <- true_pos / (true_pos + false_neg)
cat("Sensitivity is ", sens)

spec <- true_neg / (true_neg + false_pos)
cat("  Specificity is ", spec)
}
```



Set up the database connection
```{r}
con <- DBI::dbConnect(odbc::odbc(), 
                      Driver = "SQL Server", 
                      Server = "IT049561\\SQLEXPRESS", 
                      Database = "MPC", 
                      Trusted_Connection = "True")
```


Get a dataframe for each beam energy
```{sql connection=con, output.var = "df6x"}
SELECT *
FROM "6x"
```
```{sql connection=con, output.var = "df10x"}
SELECT *
FROM "10x"

```
```{sql connection=con, output.var = "df10fff"}
SELECT *
FROM "10fff"

```

Get the dataframes of the recent data - from 1st April 2021 when we measured the water phantom
```{sql connection=con, output.var=recent6x}
SELECt *
FROM "6x"
WHERE QA_Date >= '2021-04-01'
```

```{sql connection=con, output.var=recent10x}
SELECt *
FROM "10x"
WHERE QA_Date >= '2021-04-01'
```

```{sql connection=con, output.var=recent10fff}
SELECt *
FROM "10fff"
WHERE QA_Date >= '2021-04-01'
```

Set up the dataframes with pass/fail columns

```{r}
symmetry_threshold <- 2
flat_threshold <- 103
distance_threshold <- 0.5

# set the mpc thresholds
centre_threshold <- 0.5
uniformity_threshold <- 2
output_threshold <- 2


  
  # Add pass / fail columns to the df based on these thresholds

# 6x  
  # uniformity
recent6x$uniformity_test <- "fail"
recent6x$uniformity_test[recent6x$Uniformity<uniformity_threshold & recent6x$Uniformity>-uniformity_threshold] <- "pass"
  
  # combined symmetry
  # fail if 1 of them fails
recent6x$symm_test <- "fail"
recent6x$symm_test[recent6x$SymmInAT<symmetry_threshold & recent6x$SymmInAT>-symmetry_threshold & recent6x$SymmCrossAT<symmetry_threshold & recent6x$SymmCrossAT>-symmetry_threshold] <- "pass"
  
  
  # fail for inline only
recent6x$symm_in_test <- "fail"
recent6x$symm_in_test[recent6x$SymmInAT<symmetry_threshold & recent6x$SymmInAT>-symmetry_threshold] <- "pass"
  
  # fail for crossline only
recent6x$symm_cross_test <- "fail"
recent6x$symm_cross_test[recent6x$SymmCrossAT<symmetry_threshold & recent6x$SymmCrossAT>-symmetry_threshold] <- "pass"

# centre shift
recent6x$centre_mpc_test <- "fail"
recent6x$centre_mpc_test[recent6x$MPC_Distance<distance_threshold & recent6x$MPC_Distance>-distance_threshold] <- "pass"

recent6x$centre_cal_test <- "fail"
recent6x$centre_cal_test[recent6x$Calibrated_Distance<centre_threshold & recent6x$Calibrated_Distance>-centre_threshold] <- "pass"

# 10x
  
  # uniformity
recent6x$uniformity_test <- "fail"
recent6x$uniformity_test[recent6x$Uniformity<uniformity_threshold & recent6x$Uniformity>-uniformity_threshold] <- "pass"
  
  # combined symmetry
  # fail if 1 of them fails
recent6x$symm_test <- "fail"
recent6x$symm_test[recent6x$SymmInAT<symmetry_threshold & recent6x$SymmInAT>-symmetry_threshold & recent6x$SymmCrossAT<symmetry_threshold & recent6x$SymmCrossAT>-symmetry_threshold] <- "pass"
  
  
  # fail for inline only
recent10x$symm_in_test <- "fail"
recent10x$symm_in_test[recent10x$SymmInAT<symmetry_threshold & recent10x$SymmInAT>-symmetry_threshold] <- "pass"
  
  # fail for crossline only
recent10x$symm_cross_test <- "fail"
recent10x$symm_cross_test[recent10x$SymmCrossAT<symmetry_threshold & recent10x$SymmCrossAT>-symmetry_threshold] <- "pass"

# centre shift
recent10x$centre_mpc_test <- "fail"
recent10x$centre_mpc_test[recent10x$MPC_Distance<distance_threshold & recent10x$MPC_Distance>-distance_threshold] <- "pass"

recent10x$centre_cal_test <- "fail"
recent10x$centre_cal_test[recent10x$Calibrated_Distance<centre_threshold & recent10x$Calibrated_Distance>-centre_threshold] <- "pass"

# 10fff
  
  # uniformity
recent10fff$uniformity_test <- "fail"
recent10fff$uniformity_test[recent10fff$Uniformity<uniformity_threshold & recent10fff$Uniformity>-uniformity_threshold] <- "pass"
  
  # combined symmetry
  # fail if 1 of them fails
recent10fff$symm_test <- "fail"
recent10fff$symm_test[recent10fff$SymmInAT<symmetry_threshold & recent10fff$SymmInAT>-symmetry_threshold & recent10fff$SymmCrossAT<symmetry_threshold & recent10fff$SymmCrossAT>-symmetry_threshold] <- "pass"
  
  
  # fail for inline only
recent10fff$symm_in_test <- "fail"
recent10fff$symm_in_test[recent10fff$SymmInAT<symmetry_threshold & recent10fff$SymmInAT>-symmetry_threshold] <- "pass"
  
  # fail for crossline only
recent10fff$symm_cross_test <- "fail"
recent10fff$symm_cross_test[recent10fff$SymmCrossAT<symmetry_threshold & recent10fff$SymmCrossAT>-symmetry_threshold] <- "pass"

# centre shift
recent10fff$centre_mpc_test <- "fail"
recent10fff$centre_mpc_test[recent10fff$MPC_Distance<distance_threshold & recent10fff$MPC_Distance>-distance_threshold] <- "pass"

recent10fff$centre_cal_test <- "fail"
recent10fff$centre_cal_test[recent10fff$Calibrated_Distance<centre_threshold & recent10fff$Calibrated_Distance>-centre_threshold] <- "pass"
```


Remove outliers from the recent dfs so that we don't skew the results? Particularlay for 10FFF. While these data points are valid, they are going to mess up all the results - we know the flattening free will have bigger fluctuations but retaining them bias's the analysis; it removes the actual relationship from sight - SD and mean are sensitive to outliers and look at the boxplot - we can't see most of the spread - including outliers means that later we can't see the correlations.

```{r}
boxplot(recent10fff$SymmInAT, recent10fff$SymmCrossAT)
boxplot(recent10fff$FlatCrossAT, recent10fff$FlatInAT)

boxplot(recent10fff$SymmInBT, recent10fff$SymmCrossBT)
boxplot(recent10fff$FlatCrossBT, recent10fff$FlatInBT)

is.numeric(recent10fff$SymmInAT)
sapply(recent10fff, class)

q <- as.numeric(recent10fff$SymmInAT)
sapply(q,class)
quantile(q)

Q1 <- quantile(recent10fff$SymmInAT)
iqr <- IQR(recent10fff$SymmInAT)
up <-  Q[2]+1.5*iqr # Upper Range  
low<- Q[1]-1.5*iqr

eliminated<- subset(recent10fff, recent10fff$SymmInAT > (Q[1] - 1.5*iqr) & recent10fff$SymmInAT < (Q[2]+1.5*iqr))
boxplot(recent10fff$SymmInAT, eliminated)

```


Descriptive statistics with psych
```{r, echo = FALSE}
describeBy(df6x$MPC_Distance)

describeBy(df6x$Calibrated_Distance)

describeBy(df6x$Uniformity)

describeBy(df6x$Output_Change)
```


Define the random samples
```{r}
set.seed(1) # set seed makes the analysis reproducible
rand_6x <- recent6x[sample(nrow(recent6x), size=50), ]
rand_10x <- recent10x[sample(nrow(recent10x), size=50), ]
rand_10fff <- recent10fff[sample(nrow(recent10fff), size=50), ]
```


Z tests 
Symmetry inline and crossline directions after calibration

Z test null hypothesis: the means of the two groups are equal
The Z test statistic is inside the 95% confidence interval, so we can not reject the null hypothesis. 
The p-value tells us how statistically significant this is and it is quite large; but still we don't have enough evidence to reject the null hypothesis.

6x
```{r}
boxplot(rand_6x$SymmInAT, rand_6x$SymmCrossAT)
z.paired(rand_6x$SymmInAT, rand_6x$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_6x$FlatInAT, rand_6x$FlatCrossAT)
z.paired(rand_6x$FlatInAT, rand_6x$FlatCrossAT, 0, alpha = 0.05)
```

10x
```{r}
boxplot(rand_10x$SymmInAT, rand_10x$SymmCrossAT)
z.paired(rand_10x$SymmInAT, rand_10x$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_10x$FlatInAT, rand_10x$FlatCrossAT)
z.paired(rand_10x$FlatInAT, rand_10x$FlatCrossAT, 0, alpha = 0.05)
```

10fff
```{r}
boxplot(rand_10fff$SymmInAT, rand_10fff$SymmCrossAT)
z.paired(rand_10fff$SymmInAT, rand_10fff$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_10fff$FlatInAT, rand_10fff$FlatCrossAT)
z.paired(rand_10fff$FlatInAT, rand_10fff$FlatCrossAT, 0, alpha = 0.05)
```


Paired Z tests to see if there's a significant difference as a result of applying the calibration transformation.
6x
```{r}
boxplot(rand_6x$SymmInBT, rand_6x$SymmInAT)
z.paired(rand_6x$SymmInBT, rand_6x$SymmInAT, 0, alpha = 0.05)

boxplot(rand_6x$SymmCrossBT, rand_6x$SymmCrossAT)
z.paired(rand_6x$SymmCrossBT, rand_6x$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_6x$FlatInBT, rand_6x$FlatInAT)
z.paired(rand_6x$FlatInBT, rand_6x$FlatInAT, 0, alpha = 0.05)

boxplot(rand_6x$FlatCrossBT, rand_6x$FlatCrossAT)
z.paired(rand_6x$FlatCrossBT, rand_6x$FlatCrossAT, 0, alpha = 0.05)
```
10x
```{r}
boxplot(rand_10x$SymmInBT, rand_10x$SymmInAT)
z.paired(rand_10x$SymmInBT, rand_10x$SymmInAT, 0, alpha = 0.05)

boxplot(rand_10x$SymmCrossBT, rand_10x$SymmCrossAT)
z.paired(rand_10x$SymmCrossBT, rand_10x$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_10x$FlatInBT, rand_10x$FlatInAT)
z.paired(rand_10x$FlatInBT, rand_10x$FlatInAT, 0, alpha = 0.05)

boxplot(rand_10x$FlatCrossBT, rand_10x$FlatCrossAT)
z.paired(rand_10x$FlatCrossBT, rand_10x$FlatCrossAT, 0, alpha = 0.05)
```
10fff
```{r}
boxplot(rand_10fff$SymmInBT, rand_10fff$SymmInAT)
z.paired(rand_10fff$SymmInBT, rand_10fff$SymmInAT, 0, alpha = 0.05)

boxplot(rand_10fff$SymmCrossBT, rand_10fff$SymmCrossAT)
z.paired(rand_10fff$SymmCrossBT, rand_10fff$SymmCrossAT, 0, alpha = 0.05)

boxplot(rand_10fff$FlatInBT, rand_10fff$FlatInAT)
z.paired(rand_10fff$FlatInBT, rand_10fff$FlatInAT, 0, alpha = 0.05)

boxplot(rand_10fff$FlatCrossBT, rand_10fff$FlatCrossAT)
z.paired(rand_10fff$FlatCrossBT, rand_10fff$FlatCrossAT, 0, alpha = 0.05)
```

Compare the beam centre shift
```{r}
boxplot(rand_6x$MPC_Distance, rand_6x$Calibrated_Distance)
z.paired(rand_6x$MPC_Distance, rand_6x$Calibrated_Distance, 0.5, alpha = 0.05)

boxplot(rand_10x$MPC_Distance, rand_10x$Calibrated_Distance)
z.paired(rand_10x$MPC_Distance, rand_10x$Calibrated_Distance, 0.5, alpha = 0.05)

boxplot(rand_10fff$MPC_Distance, rand_10fff$Calibrated_Distance)
z.paired(rand_10fff$MPC_Distance, rand_10fff$Calibrated_Distance, 0.5, alpha = 0.05)

```



Sensitivty and Specificty

```{r}

sens_spec(recent6x$uniformity_test, recent6x$symm_test)

sens_spec(recent6x$uniformity_test, recent6x$symm_in_test)

sens_spec(recent6x$uniformity_test, recent6x$symm_cross_test)


sens_spec(recent6x$centre_mpc_test, recent6x$centre_cal_test)

```

Percentage difference of symmetry to uniformity
```{r}
ratio <- recent6x$SymmInAT / recent6x$Uniformity
mean(ratio)

ratio <- recent6x$SymmCrossAT / recent6x$Uniformity
mean(ratio)

recent6x$AvSymm <- (recent6x$SymmInAT + recent6x$SymmCrossAT) / 2
mean( recent6x$AvSymm / recent6x$Uniformity)
```

Compare the symmetry in each direction to the uniformity
```{r}
boxplot(rand_6x$SymmInAT, rand_6x$SymmCrossAT, rand_6x$Uniformity)
boxplot(rand_10x$SymmInAT, rand_10x$SymmCrossAT, rand_10x$Uniformity)
boxplot(rand_10fff$SymmInAT, rand_10fff$SymmCrossAT, rand_10fff$Uniformity)
```


Are there a correlations between symmetry, flatness and uniformity, output change?

```{r}
Symm_Flat_Rel(recent6x)
```
```{r}
Symm_Flat_Rel(recent10x)
```
```{r}
Symm_Flat_Rel(recent10fff)
```


```{r}
plot_cor(recent6x, energy = "6x")
plot_cor(recent10x, energy = "10x")
plot_cor(recent10fff, energy = "10FFF")
```


```{r}

fit3 <- lm(SymmInAT ~ poly(SymmCrossAT , 4, raw=TRUE), recent6x) # random sample of whole dataset? 
summary(fit3)
```

plot the beam output change over time
```{r}
ggplot(df6x, aes(QA_Date, Output_Change)) +
  geom_point() +
  xlab("QA Date") +
  ylab("Output Change") +
  ggtitle("Output Changes against Time")

ggplot(recent6x, aes(x = QA_Date, y = SymmInAT)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  xlab("QA Date") +
  ylab("symm") +
  ggtitle("symm Changes against Time")

ggplot(recent6x, aes(x = QA_Date, y = SymmCrossAT)) +
  geom_point() +
   geom_smooth(method = 'loess') +
  xlab("QA Date") +
  ylab("symm") +
  ggtitle("symm Changes against Time")

ggplot(recent6x, aes(x = QA_Date, y = FlatInAT)) +
  geom_point() +
   geom_smooth(method = 'loess') +
  xlab("QA Date") +
  ylab("symm") +
  ggtitle("symm Changes against Time")

ggplot(recent6x, aes(x = QA_Date, y = FlatCrossAT)) +
  geom_point() +
   geom_smooth(method = 'loess') +
  xlab("QA Date") +
  ylab("symm") +
  ggtitle("symm Changes against Time")

n <-length(recent6x$SymmCrossAT)
newdata <- 1:10*n
recent6x$index <- 1:n
loessmod <- loess(SymmCrossAT ~ index, data = recent6x)
smoothed <- predict(loessmod, newdata = newdata)
plot(x = recent6x$QA_Date, y = recent6x$SymmCrossAT)
lines(smoothed, x = newdata)
```

```{r}
dat_ts <- ts(recent6x, frequency = 5)
naive(dat_ts, h = 12)
```
Forecasting
```{r}
# Fit and forecast with auto.arima()
TS6x = ts(recent6x, frequency = 5)
autoarima_fit = auto.arima(TS6x[,7]) # number specifies the data column

#autoArimaFit <- auto.arima(recent6x)
plot(forecast(autoarima_fit, h=20))

# Fit and forecast with Arima()
#arimaFit <- Arima(recent6x,order=c(3,1,0))
#plot(forecast(arimafit,h=20))
```


Polynomial regression on this year for beam output change  -predicting this can help management by forecasting when it will need to be reset so we can plan around this.

```{r}
recent6x$index <- 1:length(recent6x$Output_Change)

fit <- lm(Output_Change ~ poly(index , 56, raw=TRUE), recent6x)  
fit4 <- lm(Output_Change ~ poly(index , 14, raw=TRUE), recent6x)


plot(recent6x$Output_Change, main="plot", xaxt="n")
tck <- c(1, 25, 50, 75)
axis(1, tck, labels=FALSE)
mtext(recent6x$QA_Date[tck], 1, 1, at=tck)
lines(fit$fitted.values, col=3, lwd=2)
lines(fit4$fitted.values, col=2, lwd=2)
legend("topleft", c("cubic", "quartic"), lwd=2, col=3:2)
```


SPC charts for the beam centre shift over time;
the flatness and symmetry over time
```{r}

qic(df10x$MPC_Distance, chart = 'i')
qic(recent10x$Calibrated_Distance, chart = 'i')
qic(df10x$MPC_Distance, chart = 'mr')
qic(recent10x$Calibrated_Distance, chart = 'mr')

qic(df6x$Output_Change, x = df6x$QA_Date, chart = 'xbar')

qic(recent6x$SymmInAT, x = recent6x$QA_Date, chart = 'mr')

```




