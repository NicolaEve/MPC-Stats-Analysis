---
title: "MPC"
author: "NCompton"
date: "28/06/2021"
output: html_document
---

knit at end

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

install packages and set libraries
```{r, echo = FALSE}
#install.packages("odbc")
#install.packages("DBI")
#install.packages("dplyr")
#install.packages("fitdistrplus")
#install.packages("ggplot2")
#install.packages("qicharts2")
#install.packages("psych")
#install.packages("distributions3")
library(psych)
library(qicharts2)
library(ggplot2)
library(fitdistrplus)
library(dplyr)
library(odbc)
library(distributions3)
```

Define functions
```{r}
# function to check the distribution of the data input
check_distribution <- function(data){
  descdist(data, discrete = FALSE)
  normal_dist <- fitdist(data, "norm")
  plot(normal_dist)
}

```

```{r}
# function to return 2-sample z statistic and p value
z.test <- function(x, y){
  # get the sample mean, sd and n
  mu_1 = mean(x)
  mu_2 = mean(y)
  sigma_1 = sd(x)^2
  sigma_2 = sd(y)^2
  n_1 = length(x)
  n_2 = length(y)
  
  # calculate 2 tailed z stat
  z_stat = (mu_1 - mu_2) / (sqrt ((sigma_1/n_1) + (sigma_2/n_2)))
  
  # calculate p value
  Z <- Normal(0,1) # make a standard normal r.v
  p = 2 * cdf(Z, abs(z_stat))
  return(c(z_stat, p))
}
```

```{r}
z.paired <- function(x, y, d0, alpha){
  mean_diff <- mean(x-y)
  sigma_diff <- sqrt(var(x)+var(y)-2*cov(x,y))
  n <- length(x)
  z<-sqrt(n)*((mean_diff-d0)/sigma_diff)
  p_value=2*pnorm(-abs(z))
  
    # qnorm gives the alpha quantile of the standard normal  distribution
  # reject H0 that difference of means = d0 if z < z(alpha/2) or
  # z > z(1-alpha/2)
  
  
  if(z < qnorm(alpha/2)) {cat("Null hypothesis can be rejected. Evidence the difference in means is not equal to", d0)}
  if (z > qnorm(1 - (alpha/2))) {
  print("Null hypothesis can be rejected. Evidence the difference in means is not equal to", d0)}
  if ( qnorm(alpha/2)< z & z < qnorm(1- (alpha/2))) {  cat("Null hypothesis can not be rejected, evidence the difference in means is equal to", d0)}
  
  return(c(z, p_value))
}
```


Set up the database connection
```{r}
con <- DBI::dbConnect(odbc::odbc(), 
                      Driver = "SQL Server", 
                      Server = "IT049561\\SQLEXPRESS", 
                      Database = "MPC", 
                      Trusted_Connection = "True")
```


Get a dataframe for each beam energy
```{sql connection=con, output.var = "df6x"}
SELECT *
FROM "6x"
```
```{sql connection=con, output.var = "df10x"}
SELECT *
FROM "10x"

```
```{sql connection=con, output.var = "df10fff"}
SELECT *
FROM "10fff"

```

Get the dataframes of the recent data - from 1st April 2021 when we measured the water phantom
```{sql connection=con, output.var=recent6x}
SELECt *
FROM "6x"
WHERE QA_Date >= '2021-04-01'
```

```{sql connection=con, output.var=recent10x}
SELECt *
FROM "10x"
WHERE QA_Date >= '2021-04-01'
```

```{sql connection=con, output.var=recent10fff}
SELECt *
FROM "10fff"
WHERE QA_Date >= '2021-04-01'
```

Descriptive statistics with psych
```{r, echo = FALSE}
describeBy(df6x$MPC_Distance)

describeBy(df6x$Calibrated_Distance)

describeBy(df6x$Uniformity)

describeBy(df6x$Output_Change)
```

Comparing the symmetry and flatness before and after the calibration applied; and in inline and crossline directions
We use paired z tests
Z test null hypothesis: the means of the two groups are equal


Taking a random sample from the data and applying paired Z test
Energy: 6x
Comparing: Symmetry inline and crossline directions after calibration
The Z test statistic is inside the 95% confidence interval, so we can not reject the null hypothesis. 
The p-value tells us how statistically significant this is and it is quite large; but still we don't have enough evidence to reject the null hypothesis.
```{r}
boxplot(df6x$SymmInAT, df6x$SymmCrossAT)
set.seed(1) # set seed makes the analysis reproducible
rand_df <- df6x[sample(nrow(df6x), size=100), ]
z.paired(rand_df$SymmInAT, rand_df$SymmCrossAT, 0, alpha = 0.05)

boxplot(df6x$FlatInAT, df6x$FlatCrossAT)
z.paired(rand_df$FlatInAT, rand_df$FlatCrossAT, 0, alpha = 0.05)
```

Energy 10x
Comparing symmetry inline and crossline after calibration
The null hypothesis can be rejected at a good confidence level. The means are statistically significantly different, with a good level of confidence due to the small p value. 
```{r}
boxplot(df10x$SymmInAT, df10x$SymmCrossAT)
set.seed(6) # set seed makes the analysis reproducible
rand_10x <- df10x[sample(nrow(df10x), size=100), ]
z.paired(rand_10x$SymmInAT, rand_10x$SymmCrossAT, 0, alpha = 0.05)

boxplot(df10x$FlatInAT, df10x$FlatCrossAT)
z.paired(rand_10x$FlatInAT, rand_10x$FlatCrossAT, 0, alpha = 0.05)
```
Energy 10fff
Comparing symmetry inline and crossline
Null hypothesis can be rejected at a good level of confidence (small p value)
Means are significantly different.
```{r}
boxplot(df10fff$SymmInAT, df10fff$SymmCrossAT)
set.seed(2) # set seed makes the analysis reproducible
rand_10fff <- df10fff[sample(nrow(df10fff), size=100), ]
z.paired(rand_10fff$SymmInAT, rand_10fff$SymmCrossAT, 0, alpha = 0.05)

boxplot(df10fff$FlatInAT, df10fff$FlatCrossAT)
z.paired(rand_10fff$FlatInAT, rand_10fff$FlatCrossAT, 0, alpha = 0.05)
```
Paired Z tests to see if there's a significant difference as a result of applying the calibration transformation.
6x
```{r}
boxplot(df6x$SymmInBT, df6x$SymmInAT)
z.paired(rand_df$SymmInBT, rand_df$SymmInAT, 0, alpha = 0.05)

boxplot(df6x$SymmCrossBT, df6x$SymmCrossAT)
z.paired(rand_df$SymmCrossBT, rand_df$SymmCrossAT, 0, alpha = 0.05)

boxplot(df6x$FlatInBT, df6x$FlatInAT)
z.paired(rand_df$FlatInBT, rand_df$FlatInAT, 0, alpha = 0.05)

boxplot(df6x$FlatCrossBT, df6x$FlatCrossAT)
z.paired(rand_df$FlatCrossBT, rand_df$FlatCrossAT, 0, alpha = 0.05)
```
10x
```{r}
boxplot(df10x$SymmInBT, df10x$SymmInAT)
z.paired(rand_10x$SymmInBT, rand_10x$SymmInAT, 0, alpha = 0.05)

boxplot(df10x$SymmCrossBT, df10x$SymmCrossAT)
z.paired(rand_10x$SymmCrossBT, rand_10x$SymmCrossAT, 0, alpha = 0.05)

boxplot(df10x$FlatInBT, df10x$FlatInAT)
z.paired(rand_10x$FlatInBT, rand_10x$FlatInAT, 0, alpha = 0.05)

boxplot(df10x$FlatCrossBT, df10x$FlatCrossAT)
z.paired(rand_10x$FlatCrossBT, rand_10x$FlatCrossAT, 0, alpha = 0.05)
```
10fff
```{r}
boxplot(df10fff$SymmInBT, df10fff$SymmInAT)
z.paired(rand_10fff$SymmInBT, rand_10fff$SymmInAT, 0, alpha = 0.05)

boxplot(df10fff$SymmCrossBT, df10fff$SymmCrossAT)
z.paired(rand_10fff$SymmCrossBT, rand_10fff$SymmCrossAT, 0, alpha = 0.05)

boxplot(df10fff$FlatInBT, df10fff$FlatInAT)
z.paired(rand_10fff$FlatInBT, rand_10fff$FlatInAT, 0, alpha = 0.05)

boxplot(df10fff$FlatCrossBT, df10fff$FlatCrossAT)
z.paired(rand_10fff$FlatCrossBT, rand_10fff$FlatCrossAT, 0, alpha = 0.05)
```
Compare the beam centre shift
```{r}
boxplot(df6x$MPC_Distance, df6x$Calibrated_Distance)
z.paired(rand_df$MPC_Distance, rand_df$Calibrated_Distance, 0.5, alpha = 0.05)

boxplot(df10x$MPC_Distance, df10x$Calibrated_Distance)
z.paired(rand_10x$MPC_Distance, rand_10x$Calibrated_Distance, 0.5, alpha = 0.05)

boxplot(df10fff$MPC_Distance, df10fff$Calibrated_Distance)
z.paired(rand_10fff$MPC_Distance, rand_10fff$Calibrated_Distance, 0.5, alpha = 0.05)

```


Thresholds for passing the MPC tests are
centre shift = 0.5
OutputChange = 2
Uniformity = 2

Add column which will be a pass/fail for the mpc uniformity and one for if any of the 4 symm/flat fails
will this give sensitivity and specificity 
or it will give another metric for comparative stats
there's no mpc that fail and loads of calibrated that do
should there be a cut off?

```{r}
df6x$uniformity_test <- "fail"
df6x$uniformity_test[df6x$Uniformity<2 & df6x$Uniformity>-2] <- "pass"

df6x$symm_test <- "fail"
df6x$symm_test[df6x$SymmInAT<2 & df6x$SymmInAT>-2 & df6x$SymmCrossAT<2 & df6x$SymmCrossAT>-2] <- "pass"


recent6x$uniformity_test <- "fail"
recent6x$uniformity_test[recent6x$Uniformity<2 & recent6x$Uniformity>-2] <- "pass"

recent6x$symm_test <- "fail"
recent6x$symm_test[recent6x$SymmInAT<2 & recent6x$SymmInAT>-2 & recent6x$SymmCrossAT<2 & recent6x$SymmCrossAT>-2] <- "pass"

false_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$symm_test == "fail")
true_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$symm_test == "pass")
false_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$symm_test == "pass")
true_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$symm_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$uniformity_test == "pass" & df6x$symm_test == "fail")
true_pos <- sum(df6x$uniformity_test == "pass" & df6x$symm_test == "pass")
false_neg <- sum(df6x$uniformity_test == "fail" & df6x$symm_test == "pass")
true_neg <- sum(df6x$uniformity_test == "fail" & df6x$symm_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```
```{r}
df6x$flat_test <- "fail"
df6x$flat_test[df6x$FlatInAT<104 & df6x$FlatCrossAT<104] <- "pass"

recent6x$flat_test <- "fail"
recent6x$flat_test[recent6x$FlatInAT<104 & recent6x$FlatCrossAT<104] <- "pass"

false_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$flat_test == "fail")
true_pos <- sum(recent6x$uniformity_test == "pass" & recent6x$flat_test == "pass")
false_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$flat_test == "pass")
true_neg <- sum(recent6x$uniformity_test == "fail" & recent6x$flat_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$uniformity_test == "pass" & df6x$flat_test == "fail")
true_pos <- sum(df6x$uniformity_test == "pass" & df6x$flat_test == "pass")
false_neg <- sum(df6x$uniformity_test == "fail" & df6x$flat_test == "pass")
true_neg <- sum(df6x$uniformity_test == "fail" & df6x$flat_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```
sensitivity and specificity of beam centre shift
the MPC distance is always within 0.5mm threshold
```{r}
df6x$centre_mpc_test <- "fail"
df6x$centre_mpc_test[df6x$MPC_Distance<0.5 & df6x$MPC_Distance>-0.5] <- "pass"

df6x$centre_cal_test <- "fail"
df6x$centre_cal_test[df6x$Calibrated_Distance<0.5 & df6x$Calibrated_Distance>-0.5] <- "pass"

recent6x$centre_mpc_test <- "fail"
recent6x$centre_mpc_test[recent6x$MPC_Distance<0.5 & recent6x$MPC_Distance>-0.5] <- "pass"

recent6x$centre_cal_test <- "fail"
recent6x$centre_cal_test[recent6x$Calibrated_Distance<0.5 & recent6x$Calibrated_Distance>-0.5] <- "pass"

false_pos <- sum(recent6x$centre_mpc_test == "pass" & recent6x$centre_cal_test == "fail")
true_pos <- sum(recent6x$centre_mpc_test == "pass" & recent6x$centre_cal_test == "pass")
false_neg <- sum(recent6x$centre_mpc_test == "fail" & recent6x$centre_cal_test == "pass")
true_neg <- sum(recent6x$centre_mpc_test == "fail" & recent6x$centre_cal_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)

false_pos <- sum(df6x$centre_mpc_test == "pass" & df6x$centre_cal_test == "fail")
true_pos <- sum(df6x$centre_mpc_test == "pass" & df6x$centre_cal_test == "pass")
false_neg <- sum(df6x$centre_mpc_test == "fail" & df6x$centre_cal_test == "pass")
true_neg <- sum(df6x$centre_mpc_test == "fail" & df6x$centre_cal_test == "fail")

sens <- true_pos / (true_pos + false_neg)
print(sens)

spec <- true_neg / (true_neg + false_pos)
print(spec)
```

plot the beam output change over time
```{r}
ggplot(df6x, aes(QA_Date, Output_Change)) +
  geom_point() +
  xlab("QA Date") +
  ylab("Output Change") +
  ggtitle("Output Changes against Time")

```
polynomial regression model

```{r}
df6x$index <- 1:length(df6x$Output_Change)

fit3 <- lm(Output_Change ~ poly(index , 56, raw=TRUE), df6x)  
fit4 <- lm(Output_Change ~ poly(index , 14, raw=TRUE), df6x)  ## quartic
summary(fit3)

plot(df6x$Output_Change, main="plot", xaxt="n")
tck <- c(1, 50, 100, 150)
axis(1, tck, labels=FALSE)
mtext(df6x$QA_Date[tck], 1, 1, at=tck)
lines(fit3$fitted.values, col=3, lwd=2)
lines(fit4$fitted.values, col=2, lwd=2)
legend("topleft", c("cubic", "quartic"), lwd=2, col=3:2)
```

Polynomial regression on this year

```{r}
recent6x$index <- 1:length(recent6x$Output_Change)

fit <- lm(Output_Change ~ poly(index , 56, raw=TRUE), recent6x)  
fit4 <- lm(Output_Change ~ poly(index , 14, raw=TRUE), recent6x)
summary(fit3)

plot(recent6x$Output_Change, main="plot", xaxt="n")
tck <- c(1, 50, 100, 150)
axis(1, tck, labels=FALSE)
mtext(recent6x$QA_Date[tck], 1, 1, at=tck)
lines(fit$fitted.values, col=3, lwd=2)
lines(fit4$fitted.values, col=2, lwd=2)
legend("topleft", c("cubic", "quartic"), lwd=2, col=3:2)
```


SPC charts for the beam centre shift over time;
the flatness and symmetry over time
```{r}

qic(df10x$MPC_Distance, chart = 'i')
qic(df10x$Calibrated_Distance, chart = 'i')
qic(df10x$MPC_Distance, chart = 'mr')
qic(df10x$Calibrated_Distance, chart = 'mr')

qic(df6x$Output_Change, x = df6x$QA_Date, chart = 'xbar')

qic(df6x$SymmInAT, chart = 'mr')

```


```{r}
qic(recent6x$SymmInAT, x = recent6x$QA_Date, chart = 'mr')
```


